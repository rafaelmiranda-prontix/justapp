generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model accounts {
  id                String  @id
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  users             users   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model advogado_especialidades {
  advogadoId      String
  especialidadeId String
  advogados       advogados      @relation(fields: [advogadoId], references: [id], onDelete: Cascade)
  especialidades  especialidades @relation(fields: [especialidadeId], references: [id], onDelete: Cascade)

  @@id([advogadoId, especialidadeId])
}

model advogados {
  id                      String                    @id
  userId                  String                    @unique
  oab                     String                    @unique
  oabVerificado           Boolean                   @default(false)
  aprovado                Boolean                   @default(false) // Aprovação manual pelo admin
  bio                     String?
  fotoUrl                 String?
  cidade                  String
  estado                  String
  latitude                Float?
  longitude               Float?
  raioAtuacao             Int                       @default(50)
  precoConsulta           Float?
  aceitaOnline            Boolean                   @default(true)
  aceitaOutrosEstados     Boolean                   @default(false)
  plano                   Plano                     @default(FREE)
  planoExpira             DateTime?
  stripeCustomerId        String?                   @unique
  stripeSubscriptionId    String?                   @unique
  leadsRecebidosMes       Int                       @default(0)
  leadsLimiteMes          Int                       @default(0)
  ultimoResetLeads        DateTime                  @default(now())
  casosRecebidosHora      Int                       @default(0)
  ultimoResetCasosHora    DateTime                  @default(now())
  isBeta                  Boolean                   @default(false)
  betaInviteCode          String?                   @unique
  onboardingCompleted     Boolean                   @default(false)
  createdAt               DateTime                  @default(now())
  updatedAt               DateTime
  advogado_especialidades advogado_especialidades[]
  users                   users                     @relation(fields: [userId], references: [id], onDelete: Cascade)
  avaliacoes              avaliacoes[]
  matches                 matches[]
  historicoAssinaturas    historicoAssinaturas[]
}

model AnonymousSession {
  id                     String        @id
  sessionId              String        @unique
  mensagens              Json[]
  userAgent              String?
  ipAddress              String?
  cidade                 String?
  estado                 String?
  especialidadeDetectada String?
  urgenciaDetectada      String?
  preQualificationState  Json?
  preQualificationScore  Int?
  useAI                  Boolean       @default(false)
  status                 SessionStatus @default(ACTIVE)
  convertedToUserId      String?       @unique
  convertedToCasoId      String?       @unique
  createdAt              DateTime      @default(now())
  updatedAt              DateTime
  expiresAt              DateTime

  @@index([createdAt])
  @@index([sessionId])
  @@index([status])
  @@map("anonymous_sessions")
}

model avaliacoes {
  id         String    @id
  cidadaoId  String
  advogadoId String
  nota       Int
  comentario String?
  createdAt  DateTime  @default(now())
  advogados  advogados @relation(fields: [advogadoId], references: [id], onDelete: Cascade)
  cidadaos   cidadaos  @relation(fields: [cidadaoId], references: [id], onDelete: Cascade)

  @@unique([cidadaoId, advogadoId])
  @@index([advogadoId])
}

model casos {
  id                  String          @id
  cidadaoId           String
  descricao           String // Resumo do problema (não concatenado)
  descricaoIA         String? // Análise da IA sobre o caso
  conversaHistorico   Json? // Histórico completo do chat anônimo
  especialidadeId     String?
  urgencia            Urgencia        @default(NORMAL)
  complexidade        Int             @default(1)
  status              CasoStatus      @default(PENDENTE_ATIVACAO)
  sessionId           String?         @unique
  redistribuicoes     Int             @default(0) // Contador de redistribuições após recusas
  // Mediação pelo admin
  mediatedByAdminId   String?
  mediatedAt          DateTime?
  // Fechamento pelo admin
  closedByAdminId     String?
  closedAt            DateTime?
  closeReason         CloseReason?
  closeSummary        String?
  // Checklist para fechamento (documentos, infos, orientação, encaminhado)
  checklist           Json?           // { documentosRecebidos, informacoesMinimas, orientacaoEnviada, encaminhadoAdvogado }
  createdAt           DateTime        @default(now())
  updatedAt           DateTime
  cidadaos            cidadaos        @relation(fields: [cidadaoId], references: [id], onDelete: Cascade)
  especialidades      especialidades? @relation(fields: [especialidadeId], references: [id])
  matches             matches[]
  case_messages       case_messages[]
  mediatedByAdmin     users?            @relation("CasosMediatedBy", fields: [mediatedByAdminId], references: [id])
  closedByAdmin       users?            @relation("CasosClosedBy", fields: [closedByAdminId], references: [id])

  @@index([cidadaoId])
  @@index([especialidadeId])
  @@index([sessionId])
  @@index([status])
  @@index([mediatedByAdminId])
}

model case_messages {
  id            String                 @id
  casoId        String
  senderRole    CaseMessageSenderRole   // ADMIN | CIDADAO
  senderId      String                  // userId
  message       String
  attachmentUrls String[]               @default([]) // URLs de anexos (reaproveita upload existente)
  visibility     CaseMessageVisibility   @default(PUBLIC) // PUBLIC = admin↔cidadão; INTERNAL = só admin
  createdAt     DateTime                @default(now())
  casos         casos                   @relation(fields: [casoId], references: [id], onDelete: Cascade)
  sender        users                   @relation("CaseMessageSender", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([casoId])
  @@index([senderId])
  @@index([createdAt])
  @@map("case_messages")
}

model cidadaos {
  id         String       @id
  userId     String       @unique
  cidade     String?
  estado     String?
  latitude   Float?
  longitude  Float?
  createdAt  DateTime     @default(now())
  updatedAt  DateTime
  avaliacoes avaliacoes[]
  casos      casos[]
  users      users        @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model configuracoes {
  id        String           @id
  chave     String           @unique
  valor     String
  tipo      ConfiguracaoTipo @default(STRING)
  descricao String?
  categoria String           @default("geral")
  createdAt DateTime         @default(now())
  updatedAt DateTime

  @@index([categoria])
}

model especialidades {
  id                      String                    @id
  nome                    String                    @unique
  slug                    String                    @unique
  descricao               String?
  palavrasChave           String[]
  createdAt               DateTime                  @default(now())
  updatedAt               DateTime
  advogado_especialidades advogado_especialidades[]
  casos                   casos[]
}

model matches {
  id            String      @id
  casoId        String
  advogadoId    String
  score         Int
  distanciaKm   Float?
  status        MatchStatus @default(PENDENTE)
  enviadoEm     DateTime    @default(now())
  visualizadoEm DateTime?
  respondidoEm  DateTime?
  expiresAt     DateTime?
  notificadoEm  DateTime?
  advogados     advogados   @relation(fields: [advogadoId], references: [id], onDelete: Cascade)
  casos         casos       @relation(fields: [casoId], references: [id], onDelete: Cascade)
  mensagens     mensagens[]

  @@unique([casoId, advogadoId])
  @@index([advogadoId])
  @@index([status])
  @@index([notificadoEm])
}

model mensagens {
  id          String   @id
  matchId     String
  remetenteId String
  conteudo    String
  anexoUrl    String?
  lida        Boolean  @default(false)
  createdAt   DateTime @default(now())
  matches     matches  @relation(fields: [matchId], references: [id], onDelete: Cascade)
  remetente   users    @relation("MensagensRemetente", fields: [remetenteId], references: [id], onDelete: Cascade)

  @@index([matchId])
  @@index([remetenteId])
}

model planos {
  id                   String                 @id
  codigo               Plano                  @unique
  nome                 String
  descricao            String?
  preco                Int                    @default(0) // em centavos (R$)
  precoDisplay         Int                    @default(0) // para exibição (R$)
  leadsPerMonth        Int                    @default(0) // -1 = ilimitado
  leadsPerHour         Int                    @default(5) // -1 = ilimitado (apenas para planos ilimitados)
  features             String[] // array de features
  stripePriceId        String?                @unique
  ativo                Boolean                @default(true)
  status               String                 @default("ACTIVE") // ACTIVE, COMING_SOON, HIDDEN
  ordem                Int                    @default(0) // ordem de exibição
  createdAt            DateTime               @default(now())
  updatedAt            DateTime
  historicoAssinaturas historicoAssinaturas[]

  @@index([ativo])
  @@index([ordem])
  @@index([status])
}

model historicoAssinaturas {
  id                   String           @id
  advogadoId           String
  planoId              String
  planoAnteriorId      String? // plano que estava antes (para tracking de upgrade/downgrade)
  status               StatusAssinatura @default(ATIVA)
  precoPago            Int? // preço que foi cobrado (em centavos)
  leadsLimite          Int // limite de leads que foi configurado
  inicioEm             DateTime         @default(now())
  fimEm                DateTime? // quando cancelou ou mudou de plano
  stripeSubscriptionId String?
  stripePriceId        String?
  motivo               String? // motivo de cancelamento/mudança
  canceladoPor         CanceladoPor? // quem cancelou
  createdAt            DateTime         @default(now())
  updatedAt            DateTime
  advogados            advogados        @relation(fields: [advogadoId], references: [id], onDelete: Cascade)
  planos               planos           @relation(fields: [planoId], references: [id])

  @@index([advogadoId])
  @@index([planoId])
  @@index([status])
  @@index([inicioEm])
  @@map("historico_assinaturas")
}

enum StatusAssinatura {
  ATIVA
  CANCELADA
  EXPIRADA
  SUSPENSA
}

enum CanceladoPor {
  USUARIO
  ADMIN
  SISTEMA
  PAGAMENTO_FALHOU
}

model sessions {
  id           String   @id
  sessionToken String   @unique
  userId       String
  expires      DateTime
  users        users    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model users {
  id                String      @id
  email             String      @unique
  emailVerified     DateTime?
  name              String
  image             String?
  phone             String?
  password          String?
  role              UserRole
  status            UserStatus  @default(ACTIVE)
  activationToken   String?     @unique
  activationExpires DateTime?
  createdAt         DateTime    @default(now())
  updatedAt         DateTime
  accounts          accounts[]
  advogados         advogados?
  cidadaos          cidadaos?
  sessions          sessions[]
  mensagens         mensagens[] @relation("MensagensRemetente")
  case_messages     case_messages[] @relation("CaseMessageSender")
  casosMediated    casos[]         @relation("CasosMediatedBy")
  casosClosed      casos[]         @relation("CasosClosedBy")
}

model verification_tokens {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum CasoStatus {
  PENDENTE_ATIVACAO
  ABERTO
  EM_MEDIACAO
  EM_ANDAMENTO
  FECHADO
  CANCELADO
}

enum CloseReason {
  RESOLVIDO
  SEM_RETORNO_DO_CLIENTE
  INCOMPLETO_SEM_DOCUMENTOS
  DUPLICADO
  FORA_DO_ESCOPO
  ENCERRADO_COM_ENCAMINHAMENTO
}

enum CaseMessageSenderRole {
  ADMIN
  CIDADAO
}

enum CaseMessageVisibility {
  PUBLIC   // Visível para admin e cidadão
  INTERNAL // Apenas admin (nota interna)
}

enum ChatMode {
  MVP // Polling otimizado (sem dependências externas)
  PUSHER // WebSocket em tempo real via Pusher
}

enum ConfiguracaoTipo {
  STRING
  NUMBER
  BOOLEAN
  JSON
}

enum MatchStatus {
  PENDENTE
  VISUALIZADO
  ACEITO
  RECUSADO
  CONTRATADO
  EXPIRADO
}

enum Plano {
  FREE
  BASIC
  PREMIUM
  UNLIMITED
}

enum SessionStatus {
  ACTIVE
  CONVERTED
  ABANDONED
  EXPIRED
}

enum Urgencia {
  BAIXA
  NORMAL
  ALTA
  URGENTE
}

enum UserRole {
  CIDADAO
  ADVOGADO
  ADMIN
}

enum UserStatus {
  PRE_ACTIVE
  ACTIVE
  SUSPENDED
  DELETED
}

model security_logs {
  id               String   @id @default(uuid())
  action           String // Tipo de ação (ex: PLANO_ADVOGADO_ALTERADO)
  actorId          String // ID do usuário que executou a ação
  actorEmail       String
  actorName        String
  actorRole        String
  targetType       String // Tipo do alvo (ex: ADVOGADO, CASO, etc)
  targetId         String // ID do alvo
  targetIdentifier String? // Identificador do alvo (OAB, email, etc)
  changes          Json? // Array de mudanças [{field, from, to}]
  metadata         Json? // Metadados adicionais (IP, User-Agent, motivo, etc)
  severity         String   @default("INFO") // INFO, WARNING, CRITICAL
  createdAt        DateTime @default(now())

  @@index([action])
  @@index([actorId])
  @@index([targetType, targetId])
  @@index([createdAt])
  @@index([severity])
  @@map("security_logs")
}
